{"version":3,"file":"boll-branch-shopify-checkout.iife.js","sources":["../src/utils/buildCheckout.ts","../src/utils/cartItemsToCheckoutItems.ts","../src/utils/createGqlClient.ts","../src/utils/gql.ts","../src/utils/handleShopifyError.ts","../src/utils/isVerifiedCheckoutId.ts","../src/utils/metafieldsToCustomAttributes.ts","../src/utils/transformVariantIdToGid.ts","../src/graphql/fragments/index.ts","../src/graphql/mutations/index.ts","../src/client/actions/checkoutAttributesUpdate.ts","../src/client/actions/checkoutCreate.ts","../src/client/actions/checkoutLineItemsReplace.ts","../src/graphql/queries/index.ts","../src/client/actions/findCheckout.ts","../src/client/actions/putCheckout.ts","../src/client/actions/applyDiscount.ts","../src/client/actions/removeDiscount.ts","../src/client/index.ts"],"sourcesContent":["/**\n * Modified by David Rekow <drekow@bollandbranch.com>\n */\n\nimport { ShopifyCheckoutResponse, ShopifyCheckout, ShopifyCheckoutUserError } from '../checkout-client.types';\n\n   \nexport default function buildCheckout({\n  checkout,\n  checkoutUserErrors\n}: ShopifyCheckoutResponse): ShopifyCheckout & {\n  shopifyErrors: ShopifyCheckoutUserError[]\n} {\n  const {\n    id,\n    webUrl,\n    completedAt,\n    lineItems,\n    discountApplications\n  } = checkout ?? {\n    id: null,\n    webUrl: null,\n    lineItems: { edges: [] },\n    discountApplications: { edges: [] }\n  }\n  return {\n    id,\n    url: webUrl,\n    completed: Boolean(completedAt),\n    lines: lineItems.edges.map((edge) => edge.node),\n    discounts: discountApplications.edges.map((edge) => edge.node),\n    shopifyErrors: checkoutUserErrors\n  };\n}\n","import { CartItem, CheckoutItem } from '../checkout-client.types';\nimport {\n  metafieldsToCustomAttributes,\n  transformVariantIdToGid\n} from '../utils';\n\nexport interface CartItemsToCheckoutItemsParams {\n  cartItems: CartItem[];\n}\n\nexport default function cartItemsToCheckoutItems({\n  cartItems\n}: CartItemsToCheckoutItemsParams): CheckoutItem[] {\n  const lineItems: CheckoutItem[] = cartItems.map((cartItem) => {\n    const { quantity, variantId: providedVariantId } = cartItem;\n    const variantId = transformVariantIdToGid(providedVariantId);\n    const customAttributes = metafieldsToCustomAttributes({\n      metafields: cartItem.metafields\n    });\n\n    return { customAttributes, quantity, variantId };\n  });\n\n  return lineItems;\n}\n","import { GqlClient } from '../checkout-client.types';\nimport { CreateClientParams } from '../client';\n\n/**\n * Sanitize `(brand).myshopify.com` domains.\n */\nfunction sanitizeShopifyDomain(domain: string): string {\n  const sanitizedDomain = domain\n    ?.split('.myshopify')\n    .shift()\n    ?.split('//')\n    .pop()\n    ?.split('.')\n    .pop();\n\n  return sanitizedDomain || domain;\n}\n\nexport const fetchClientError =\n  '[@nacelle/shopify-checkout] in order to create a checkout server-side, ' +\n  'you must provide a fetch API-compatible `fetchClient` capable of running ' +\n  'on both the client & server. Examples include `isomorphic-unfetch` and `cross-fetch`.';\n\ntype CreateGqlClientParams = Pick<\n  CreateClientParams,\n  | 'customEndpoint'\n  | 'fetchClient'\n  | 'myshopifyDomain'\n  | 'storefrontCheckoutToken'\n>;\n\nexport const missingParametersErrorMessage =\n  '[@nacelle/shopify-checkout]: missing required parameters. You must provide a `myshopifyDomain` or a `customEndpoint`.';\nexport const missingAccessTokenMessage =\n  '[@nacelle/shopify-checkout]: missing required parameter `storefrontCheckoutToken`.';\n\n/**\n * Create a GraphQL client using `window.fetch` or the provided `fetchClient`\n */\nexport default function createGqlClient({\n  customEndpoint,\n  fetchClient,\n  myshopifyDomain,\n  storefrontCheckoutToken\n}: CreateGqlClientParams): GqlClient {\n  const gqlClient: GqlClient = ({ query, variables }) => {\n    let endpoint = customEndpoint || '';\n\n    if (!storefrontCheckoutToken) {\n      throw new Error(missingAccessTokenMessage);\n    }\n\n    if (!endpoint) {\n      if (!myshopifyDomain) {\n        throw new Error(missingParametersErrorMessage);\n      }\n      const domain = sanitizeShopifyDomain(myshopifyDomain || '');\n      endpoint = `https://${domain}.myshopify.com/api/2022-01/graphql`;\n    }\n\n    let fetcher = fetchClient;\n\n    if (!fetcher) {\n      if (typeof window !== 'undefined') {\n        fetcher = window.fetch;\n      } else {\n        throw new Error(fetchClientError);\n      }\n    }\n\n    return fetcher(endpoint, {\n      method: 'POST',\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n        'X-Shopify-Storefront-Access-Token': storefrontCheckoutToken\n      },\n      body: JSON.stringify({ query, variables })\n    }).then((res: Response) => res.json());\n  };\n\n  return gqlClient;\n}\n","// courtsey of @manifoldco/gql-zero (https://github.com/manifoldco/gql-zero)\n\ninterface StringCompatible {\n  toString(): string;\n}\n\n/**\n * Tagged template literal to enable syntax highlighting for inline GraphQL queries\n *\n * @example\n * import { gql } from '/path/to/utils';\n *\n * gql`\n *   query {\n *     getBirthdayInfo(user: 'nacelleBot') {\n *       date\n *       astrologySign\n *     }\n *   }\n * `\n */\nexport default function gql(\n  str: TemplateStringsArray,\n  ...values: StringCompatible[]\n): string {\n  return str.reduce((acc, s, i) => `${acc}${s}${values[i] || ''}`, '');\n}\n","import {\n  ShopifyCheckoutUserError,\n  ShopifyError\n} from '../checkout-client.types';\n\nexport interface VerboseErrorParams {\n  caller?: string;\n  message?: string;\n}\n\nexport default function handleShopifyError(\n  errors?: ShopifyCheckoutUserError[] | ShopifyError[],\n  { caller, message }: VerboseErrorParams = {}\n): void {\n  let errorMessage = '';\n\n  if (caller) {\n    errorMessage = `[${caller}] `;\n  }\n\n  errorMessage =\n    errorMessage +\n    (message || 'Shopify Storefront API Errors:') +\n    (errors ? '\\n' + JSON.stringify(errors, null, 2) : '');\n\n  throw new Error(errorMessage);\n}\n","export default function isVerifiedCheckoutId(id: string): boolean {\n  // Shopify CheckoutIds are Base64-encoded urls formatted like:\n  // 'gid://shopify/Checkout/<id>' and therefore must include 'Z2lkOi8vc2hvcGlmeS9DaGVja291dC'\n  if (!id?.length) {\n    return false;\n  }\n\n  return id.includes('Z2lkOi8vc2hvcGlmeS9DaGVja291dC') && id !== '';\n}\n","import { Attribute, Metafield } from '../checkout-client.types';\n\nexport interface ReconcileCustomAttributesParams {\n  metafields?: Metafield[];\n}\n\n/**\n * Given either `customAttributes` or `metafields`, return `customAttributes`.\n *\n * If `customAttributes` are provided, `metafields` will be ignored.\n */\nexport default function metafieldsToCustomAttributes({\n  metafields\n}: ReconcileCustomAttributesParams): Attribute[] {\n  if (!Array.isArray(metafields) || !metafields?.length) {\n    return [];\n  }\n\n  const customAttributes: Attribute[] = metafields?.reduce((fields, m) => {\n    if (typeof m.value === 'string') {\n      fields.push({ key: m.key, value: m.value });\n    } else {\n      console.warn(\n        `Omitting custom attribute \"${m.key}\" because it has a non-string value.`\n      );\n    }\n\n    return fields;\n  }, [] as Attribute[]);\n\n  return customAttributes;\n}\n","/**\n * Transforms variant ids to valid PlainText shopify gids\n * If the variant id is a valid gid, that gid will be returned instead.\n * If the variant is a Base64 encoded gid, that gid will be returned\n * @param variantId - the variant id to transform\n * @returns gid - a valid shopify variant gid of the form gid://shopify/ProductVariant/{numeric-id}\n */\nexport default function (variantId: string): string {\n  // if it's already a global id, just return it\n  if (isPlainTextGlobalId(variantId)) {\n    return variantId;\n  }\n\n  if (isNumeric(variantId)) {\n    return idToVariantGid(variantId);\n  }\n\n  const decodedVariantId = decodeBase64Id(variantId);\n\n  if (isPlainTextGlobalId(decodedVariantId)) {\n    return decodedVariantId;\n  }\n  // otherwise it's absolutely not a valid id and we should throw\n  throw Error(`${variantId} is an invalid shopify variant id`);\n}\n\nfunction isPlainTextGlobalId(variantId: string) {\n  return variantId.startsWith('gid://shopify/');\n}\n\nfunction isNumeric(variantId: string) {\n  return !Number.isNaN(Number(variantId));\n}\n\nfunction decodeBase64Id(variantId: string): string {\n  try {\n    // if window undefined, we're in node\n    if (typeof window === 'undefined') {\n      // if the decoded & re-encoded string is the same as the original, decode it. This is b/c Buffer.from won't error on invalid chars\n      if (Buffer.from(variantId, 'base64').toString('base64') === variantId) {\n        return Buffer.from(variantId, 'base64').toString();\n      } else {\n        // if it's not valid base64, just return it\n        return variantId;\n      }\n    } else {\n      // we're in the browser so use browser methods\n      // window.atob will throw if there are invalid chars, so we don't need to be as safe here\n      return window.atob(variantId);\n    }\n  } catch (err) {\n    return variantId;\n  }\n}\n\nfunction idToVariantGid(variantId: string): string {\n  return `gid://shopify/ProductVariant/${variantId}`;\n}\n","import { gql } from '../../utils';\n\nconst lineItem = gql`\n  fragment CheckoutLineItem_lineItem on CheckoutLineItem {\n    customAttributes {\n      key\n      value\n    }\n    discountAllocations {\n      allocatedAmount {\n        amount\n        currencyCode\n      }\n    }\n    id\n    quantity\n    title\n    unitPrice {\n      amount\n      currencyCode\n    }\n    variant {\n      id\n    }\n  }\n`;\n\nconst discountApplication = gql`\n  fragment DiscountApplication_discountApplication on DiscountApplication {\n    allocationMethod\n    targetSelection\n    targetType\n    ... on ScriptDiscountApplication {\n      title\n    }\n    value {\n      ... on MoneyV2 {\n        amount\n        currencyCode\n      }\n      ... on PricingPercentageValue {\n        percentage\n      }\n    }\n  }\n`;\n\nconst checkout = gql`\n  fragment Checkout_checkout on Checkout {\n    id\n    webUrl\n    lineItems(first: 100) {\n      edges {\n        node {\n          ...CheckoutLineItem_lineItem\n        }\n      }\n    }\n    discountApplications(first: 100) {\n      edges {\n        node {\n          ...DiscountApplication_discountApplication\n        }\n      }\n    }\n  }\n  ${lineItem}\n  ${discountApplication}\n`;\n\nconst userError = gql`\n  fragment CheckoutUserError_checkoutUserError on CheckoutUserError {\n    code\n    field\n    message\n  }\n`;\n\nexport default {\n  CHECKOUT: checkout,\n  USER_ERROR: userError\n};\n","/**\n * Modified by David Rekow <drekow@bollandbranch.com>\n */\n\n\nimport { gql } from '../../utils';\nimport {\n  ShopifyCheckoutUserError,\n  ShopifyCheckoutResponseProperties,\n  ShopifyCheckoutResponse\n} from '../../checkout-client.types';\nimport fragments from '../fragments';\n\nexport interface CheckoutCreateData {\n  checkoutCreate: ShopifyCheckoutResponse;\n}\n\nexport const checkoutCreate = gql`\n  mutation checkoutCreate($input: CheckoutCreateInput!) {\n    checkoutCreate(input: $input) {\n      checkout {\n        ...Checkout_checkout\n      }\n      checkoutUserErrors {\n        ...CheckoutUserError_checkoutUserError\n      }\n    }\n  }\n  ${fragments.CHECKOUT}\n  ${fragments.USER_ERROR}\n`;\n\nexport interface CheckoutLineItemsReplaceData {\n  checkoutLineItemsReplace: {\n    checkout: ShopifyCheckoutResponseProperties | null;\n    userErrors: ShopifyCheckoutUserError[];\n  };\n}\n\nexport const checkoutLineItemsReplace = gql`\n  mutation checkoutLineItemsReplace(\n    $lineItems: [CheckoutLineItemInput!]!\n    $checkoutId: ID!\n  ) {\n    checkoutLineItemsReplace(lineItems: $lineItems, checkoutId: $checkoutId) {\n      checkout {\n        ...Checkout_checkout\n      }\n      userErrors {\n        ...CheckoutUserError_checkoutUserError\n      }\n    }\n  }\n  ${fragments.CHECKOUT}\n  ${fragments.USER_ERROR}\n`;\n\nexport interface CheckoutAttributesUpdateData {\n  checkoutAttributesUpdateV2: ShopifyCheckoutResponse;\n}\n\nexport const checkoutAttributesUpdate = gql`\n  mutation checkoutAttributesUpdate(\n    $checkoutId: ID!\n    $input: CheckoutAttributesUpdateV2Input!\n  ) {\n    checkoutAttributesUpdateV2(checkoutId: $checkoutId, input: $input) {\n      checkout {\n        ...Checkout_checkout\n      }\n      checkoutUserErrors {\n        ...CheckoutUserError_checkoutUserError\n      }\n    }\n  }\n  ${fragments.CHECKOUT}\n  ${fragments.USER_ERROR}\n`;\n\nexport const checkoutDiscountCodeApplyV2 = gql`\n  mutation checkoutDiscountCodeApplyV2(\n    $checkoutId: ID!\n    $discountCode: String!\n  ) {\n    checkoutDiscountCodeApplyV2(\n      checkoutId: $checkoutId\n      discountCode: $discountCode\n    ) {\n      checkout {\n        ...Checkout_checkout\n      }\n      checkoutUserErrors {\n        ...CheckoutUserError_checkoutUserError\n      }\n    }\n  }\n  ${fragments.CHECKOUT}\n  ${fragments.USER_ERROR}\n`;\n\nexport interface CheckoutDiscountCodeApplyV2Data {\n  checkoutDiscountCodeApplyV2: ShopifyCheckoutResponse;\n}\n\nexport const checkoutDiscountCodeRemove = gql`\n  mutation checkoutDiscountCodeRemove($checkoutId: ID!) {\n    checkoutDiscountCodeRemove(checkoutId: $checkoutId) {\n      checkout {\n        ...Checkout_checkout\n      }\n      checkoutUserErrors {\n        ...CheckoutUserError_checkoutUserError\n      }\n    }\n  }\n  ${fragments.CHECKOUT}\n  ${fragments.USER_ERROR}\n`;\n\nexport interface CheckoutDiscountCodeRemoveData {\n  checkoutDiscountCodeRemove: ShopifyCheckoutResponse;\n}\n","/**\n * Modified by David Rekow <drekow@bollandbranch.com>\n */\n\n\nimport { buildCheckout, handleShopifyError } from '../../utils';\nimport {\n  checkoutAttributesUpdate as checkoutAttributesUpdateMutation,\n  CheckoutAttributesUpdateData\n} from '../../graphql/mutations';\nimport {\n  ShopifyCheckout,\n  Attribute,\n  GqlClient\n} from '../../checkout-client.types';\n\nexport interface CheckoutAttributesUpdateParams {\n  gqlClient: GqlClient;\n  /**\n   * a Shopify checkout ID.\n   */\n  id: string;\n  customAttributes?: Attribute[];\n  note?: string;\n}\n\nexport type CheckoutUpdateVariables = {\n  checkoutId: CheckoutAttributesUpdateParams['id'];\n  input: Pick<CheckoutAttributesUpdateParams, 'customAttributes' | 'note'>;\n};\n\nexport default async function checkoutAttributesUpdate({\n  gqlClient,\n  id,\n  customAttributes,\n  note\n}: CheckoutAttributesUpdateParams): Promise<ShopifyCheckout | void> {\n  const query = checkoutAttributesUpdateMutation;\n  const variables = {\n    checkoutId: id,\n    input: {\n      customAttributes,\n      note\n    }\n  };\n\n  const { data, errors } = await gqlClient<\n    CheckoutUpdateVariables,\n    CheckoutAttributesUpdateData\n  >({ query, variables }).catch((err) => {\n    throw new Error(err);\n  });\n\n  const errs = errors || data?.checkoutAttributesUpdateV2.checkoutUserErrors;\n\n  if (errs?.length) {\n    handleShopifyError(errs, { caller: 'checkoutAttributesUpdate' });\n  }\n\n  if (data?.checkoutAttributesUpdateV2.checkout) {\n    return buildCheckout(data.checkoutAttributesUpdateV2);\n  }\n}\n","/**\n * Modified by David Rekow <drekow@bollandbranch.com>\n */\n\n\nimport { buildCheckout, handleShopifyError } from '../../utils';\nimport {\n  checkoutCreate as checkoutCreateMutation,\n  CheckoutCreateData\n} from '../../graphql/mutations';\nimport {\n  Attribute,\n  CheckoutItem,\n  GqlClient,\n  ShopifyCheckout\n} from '../../checkout-client.types';\n\nexport interface CreateCheckoutParams {\n  gqlClient: GqlClient;\n  lineItems: CheckoutItem[];\n  customAttributes?: Attribute[];\n  note?: string;\n  queueToken?: string;\n}\n\nexport type CheckoutCreateVariables = {\n  input: Pick<CreateCheckoutParams, 'customAttributes' | 'lineItems' | 'note'>;\n};\n\nexport default async function createCheckout({\n  gqlClient,\n  lineItems,\n  customAttributes,\n  note,\n  queueToken\n}: CreateCheckoutParams): Promise<ShopifyCheckout | void> {\n  const query = checkoutCreateMutation;\n  const variables = {\n    input: { customAttributes, lineItems, note },\n    queueToken\n  };\n\n  try {\n    const { data, errors } = await gqlClient<\n      CheckoutCreateVariables,\n      CheckoutCreateData\n    >({\n      query,\n      variables\n    }).catch((err) => {\n      throw new Error(err);\n    });\n\n    const errs = errors || data?.checkoutCreate.checkoutUserErrors;\n\n    if (errs?.length) {\n      handleShopifyError(errors, { caller: 'checkoutCreate' });\n    }\n\n    if (data?.checkoutCreate.checkout) {\n      return buildCheckout(data.checkoutCreate);\n    }\n  } catch (err) {\n    throw new Error(String(err));\n  }\n}\n","/**\n * Modified by David Rekow <drekow@bollandbranch.com>\n */\n\n\nimport {\n  checkoutLineItemsReplace as checkoutLineItemsReplaceMutation,\n  CheckoutLineItemsReplaceData\n} from '../../graphql/mutations';\nimport { buildCheckout, handleShopifyError } from '../../utils';\nimport {\n  CheckoutItem,\n  ShopifyCheckout,\n  GqlClient\n} from '../../checkout-client.types';\n\nexport interface CheckoutLineItemsReplaceParams {\n  gqlClient: GqlClient;\n  /**\n   * a Shopify checkout ID.\n   */\n  id: string;\n  lineItems: CheckoutItem[];\n}\n\nexport type CheckoutLineItemsReplaceVariables = Pick<\n  CheckoutLineItemsReplaceParams,\n  'lineItems'\n> & { checkoutId: CheckoutLineItemsReplaceParams['id'] };\n\nexport default async function checkoutLineItemsReplace({\n  gqlClient,\n  lineItems,\n  id\n}: CheckoutLineItemsReplaceParams): Promise<ShopifyCheckout | void> {\n  const query = checkoutLineItemsReplaceMutation;\n  const variables = { checkoutId: id, lineItems };\n  const { data, errors } = await gqlClient<\n    CheckoutLineItemsReplaceVariables,\n    CheckoutLineItemsReplaceData\n  >({ query, variables }).catch((err) => {\n    throw new Error(err);\n  });\n\n  const errs = errors || data?.checkoutLineItemsReplace.userErrors;\n\n  if (errs?.length) {\n    handleShopifyError(errs, { caller: 'checkoutLineItemsReplace' });\n  }\n\n  if (data?.checkoutLineItemsReplace.checkout) {\n    return buildCheckout({\n      checkout: data?.checkoutLineItemsReplace.checkout,\n      checkoutUserErrors: data?.checkoutLineItemsReplace.userErrors\n    });\n  }\n}\n","import { gql } from '../../utils';\nimport { ShopifyCheckoutResponseProperties } from '../../checkout-client.types';\nimport fragments from '../fragments';\nexport interface GetCheckoutData {\n  node: ShopifyCheckoutResponseProperties | null;\n}\n\nexport const getCheckout = gql`\n  query getCheckout($id: ID!) {\n    node(id: $id) {\n      ... on Checkout {\n        ...Checkout_checkout\n      }\n    }\n  }\n  ${fragments.CHECKOUT}\n`;\n","/**\n * Modified by David Rekow <drekow@bollandbranch.com>\n */\n\n\nimport {\n  getCheckout as getCheckoutQuery,\n  GetCheckoutData\n} from '../../graphql/queries';\nimport { buildCheckout, handleShopifyError } from '../../utils';\nimport { ShopifyCheckout, GqlClient } from '../../checkout-client.types';\n\nexport interface FindCheckoutParams {\n  gqlClient: GqlClient;\n  /**\n   * a Shopify checkout ID.\n   */\n  id: string;\n}\n\nexport type FindCheckoutVariables = Pick<FindCheckoutParams, 'id'>;\n\nexport default async function findCheckout({\n  gqlClient,\n  id\n}: FindCheckoutParams): Promise<ShopifyCheckout | void> {\n  const query = getCheckoutQuery;\n  const variables = { id };\n\n  const { data, errors } = await gqlClient<\n    FindCheckoutVariables,\n    GetCheckoutData\n  >({ query, variables }).catch((err) => {\n    throw new Error(err);\n  });\n\n  if (errors) {\n    handleShopifyError(errors, { caller: 'findCheckout' });\n  }\n\n  if (!data?.node) {\n    handleShopifyError(undefined, {\n      caller: 'findCheckout',\n      message: 'Checkout response has no data'\n    });\n  } else {\n    return buildCheckout({\n      checkout: data.node,\n      checkoutUserErrors: []\n    });\n  }\n}\n","import {\n  checkoutAttributesUpdate,\n  checkoutLineItemsReplace,\n  checkoutCreate\n} from '../../client/actions';\nimport { isVerifiedCheckoutId } from '../../utils';\nimport { ShopifyCheckout } from '../../checkout-client.types';\nimport { CreateCheckoutParams } from '../../client/actions/checkoutCreate';\nimport { CheckoutAttributesUpdateParams } from '../../client/actions/checkoutAttributesUpdate';\nimport { CheckoutLineItemsReplaceParams } from '../../client/actions/checkoutLineItemsReplace';\n\ntype CheckoutActionIntersection = CreateCheckoutParams &\n  CheckoutAttributesUpdateParams &\n  CheckoutLineItemsReplaceParams;\n\nexport type PutCheckoutParams = Partial<CheckoutActionIntersection> &\n  Pick<CheckoutActionIntersection, 'gqlClient'>;\n\nexport default async function putCheckout({\n  gqlClient,\n  id,\n  lineItems,\n  customAttributes,\n  note,\n  queueToken\n}: PutCheckoutParams): Promise<void | ShopifyCheckout> {\n  let checkout: ShopifyCheckout | void = undefined;\n  const shouldUpdateLineItems = lineItems?.length;\n  const shouldUpdateAttributes = customAttributes?.length || note;\n\n  try {\n    if (id) {\n      if (!isVerifiedCheckoutId(id)) {\n        throw new Error(\n          `Invalid checkout ID. Expected a Base64-encoded Shopify Global ID. Received: ${id}`\n        );\n      }\n\n      const checkoutUpdatePromises: Promise<ShopifyCheckout | void>[] = [];\n\n      // Update line items\n      if (shouldUpdateLineItems) {\n        checkoutUpdatePromises.push(\n          checkoutLineItemsReplace({\n            gqlClient,\n            id,\n            lineItems\n          })\n        );\n      }\n\n      // Update attributes if provided\n      if (shouldUpdateAttributes) {\n        checkoutUpdatePromises.push(\n          checkoutAttributesUpdate({\n            gqlClient,\n            id,\n            customAttributes,\n            note\n          })\n        );\n      }\n\n      await Promise.allSettled(checkoutUpdatePromises).then((settledPromises) =>\n        settledPromises.forEach((p) => {\n          if (p.status === 'fulfilled' && p.value) {\n            // Note that the order of the promises is important here,\n            // since the last-fulfilled promise's value will overwrite\n            // the checkout data.\n            //\n            // This is why `checkoutAttributesUpdate`, which can return an updated\n            // `note` or `customAttributes`, goes after `checkoutLineItemsReplace`,\n            // which doesn't update any properties of the checkout object\n            // (the `checkoutId` remains the same after a checkoutLineItemsReplace`).\n            checkout = {\n              ...(checkout || {}),\n              ...p.value\n            };\n          } else if (p.status === 'rejected') {\n            throw new Error(p.reason);\n          }\n        })\n      );\n    }\n\n    // Create new checkout if checkout does not exist\n    if (typeof checkout === 'undefined' && typeof lineItems !== 'undefined') {\n      checkout = await checkoutCreate({\n        gqlClient,\n        customAttributes,\n        note,\n        lineItems,\n        queueToken\n      });\n    }\n\n    return checkout;\n  } catch (err) {\n    throw new Error(String(err));\n  }\n}\n","/**\n * Modified by David Rekow <drekow@bollandbranch.com>\n */\n\n\nimport {\n  buildCheckout,\n  handleShopifyError,\n  isVerifiedCheckoutId\n} from '../../utils';\nimport { GqlClient, ShopifyCheckout } from '../../checkout-client.types';\nimport {\n  checkoutDiscountCodeApplyV2,\n  CheckoutDiscountCodeApplyV2Data\n} from '../../graphql/mutations';\n\nexport interface ApplyDiscountParams {\n  gqlClient: GqlClient;\n  id: string;\n  discountCode?: string;\n  queueToken?: string;\n}\n\nexport type ApplyDiscountVariables = {\n  input: {\n    checkoutId: string;\n    discountCode?: string;\n  };\n};\n\nexport default async function applyDiscount({\n  gqlClient,\n  id,\n  discountCode,\n  queueToken\n}: ApplyDiscountParams): Promise<void | ShopifyCheckout> {\n  const query = checkoutDiscountCodeApplyV2;\n  const variables = {\n    input: { checkoutId: id, discountCode },\n    queueToken\n  };\n\n  try {\n    if (!isVerifiedCheckoutId(id)) {\n      throw new Error(\n        `Invalid checkout ID. Expected a Base64-encoded Shopify Global ID. Received: ${id}`\n      );\n    }\n\n    const { data, errors } = await gqlClient<\n      ApplyDiscountVariables,\n      CheckoutDiscountCodeApplyV2Data\n    >({\n      query,\n      variables\n    }).catch((err) => {\n      throw new Error(err);\n    });\n\n    const errs = errors || data?.checkoutDiscountCodeApplyV2.checkoutUserErrors;\n\n    if (errs?.length) {\n      handleShopifyError(errs, { caller: 'checkoutDiscountCodeApplyV2' });\n    }\n\n    if (data?.checkoutDiscountCodeApplyV2.checkout) {\n      return buildCheckout(data.checkoutDiscountCodeApplyV2);\n    }\n  } catch (error) {\n    throw new Error(String(error));\n  }\n}\n","/**\n * Modified by David Rekow <drekow@bollandbranch.com>\n */\n\n\nimport {\n  buildCheckout,\n  handleShopifyError,\n  isVerifiedCheckoutId\n} from '../../utils';\nimport { GqlClient, ShopifyCheckout } from '../../checkout-client.types';\nimport {\n  checkoutDiscountCodeRemove,\n  CheckoutDiscountCodeRemoveData\n} from '../../graphql/mutations';\n\nexport interface RemoveDiscountParams {\n  gqlClient: GqlClient;\n  id: string;\n  queueToken?: string;\n}\n\nexport type RemoveDiscountVariables = {\n  input: {\n    checkoutId: string;\n  };\n};\n\nexport default async function removeDiscount({\n  gqlClient,\n  id,\n  queueToken\n}: RemoveDiscountParams): Promise<void | ShopifyCheckout> {\n  const query = checkoutDiscountCodeRemove;\n  const variables = {\n    input: { checkoutId: id },\n    queueToken\n  };\n  try {\n    if (!isVerifiedCheckoutId(id)) {\n      throw new Error(\n        `Invalid checkout ID. Expected a Base64-encoded Shopify Global ID. Received: ${id}`\n      );\n    }\n\n    const { data, errors } = await gqlClient<\n      RemoveDiscountVariables,\n      CheckoutDiscountCodeRemoveData\n    >({\n      query,\n      variables\n    }).catch((err) => {\n      throw new Error(err);\n    });\n\n    const errs = errors || data?.checkoutDiscountCodeRemove.checkoutUserErrors;\n\n    if (errs?.length) {\n      handleShopifyError(errs, { caller: 'checkoutDiscountCodeRemove' });\n    }\n\n    if (data?.checkoutDiscountCodeRemove.checkout) {\n      return buildCheckout(data.checkoutDiscountCodeRemove);\n    }\n  } catch (error) {\n    throw new Error(String(error));\n  }\n}\n","import {\n  findCheckout,\n  putCheckout,\n  applyDiscount,\n  removeDiscount\n} from '../client/actions';\nimport { FindCheckoutParams } from '../client/actions/findCheckout';\nimport { PutCheckoutParams } from '../client/actions/putCheckout';\nimport { ApplyDiscountParams } from '../client/actions/applyDiscount';\nimport { RemoveDiscountParams } from '../client/actions/removeDiscount';\nimport {\n  cartItemsToCheckoutItems,\n  createGqlClient,\n  metafieldsToCustomAttributes\n} from '../utils';\nimport { CartItem, Metafield, ShopifyCheckout } from '../checkout-client.types';\n\nexport interface CreateClientParams {\n  storefrontCheckoutToken: string;\n  myshopifyDomain?: string;\n  customEndpoint?: string;\n  fetchClient?: typeof fetch;\n}\n\nexport type GetCheckoutParams = Pick<FindCheckoutParams, 'id'>;\nexport type DiscountApplyParams = Omit<ApplyDiscountParams, 'gqlClient'>;\nexport type DiscountRemoveParams = Omit<RemoveDiscountParams, 'gqlClient'>;\n\nexport type GetCheckout = (\n  params: GetCheckoutParams\n) => Promise<ShopifyCheckout | void>;\n\nexport type ProcessCheckoutParams = Pick<\n  PutCheckoutParams,\n  'id' | 'note' | 'queueToken'\n> & { cartItems?: CartItem[]; metafields?: Metafield[] };\n\nexport type ProcessCheckout = (\n  params: ProcessCheckoutParams\n) => Promise<void | ShopifyCheckout>;\n\nexport type ApplyDiscount = (\n  params: DiscountApplyParams\n) => Promise<void | ShopifyCheckout>;\n\nexport type RemoveDiscount = (\n  params: DiscountRemoveParams\n) => Promise<void | ShopifyCheckout>;\n\nexport interface CheckoutClient {\n  /**\n   * Retrieve a previously-created Shopify checkout.\n   */\n  get: GetCheckout;\n  /**\n   * Creates a Shopify checkout, or updates an existing Shopify checkout\n   * if a valid `checkoutId` is provided.\n   */\n  process: ProcessCheckout;\n  /**\n   * Applies and validate discount code\n   */\n  discountApply: ApplyDiscount;\n  /**\n   * Applies and validate discount code\n   */\n  discountRemove: RemoveDiscount;\n}\n\n/**\n * Create a Shopify checkout client that can:\n * - `get` an existing Shopify checkout\n * - `process` a new Shopify checkout, or update an existing Shopify checkout\n */\nexport default function createShopifyCheckoutClient({\n  storefrontCheckoutToken,\n  myshopifyDomain,\n  customEndpoint,\n  fetchClient\n}: CreateClientParams): CheckoutClient {\n  const gqlClient = createGqlClient({\n    customEndpoint,\n    fetchClient,\n    myshopifyDomain,\n    storefrontCheckoutToken\n  });\n\n  /**\n   * Retrieves a previously-created Shopify checkout.\n   */\n  async function getCheckout({\n    id\n  }: GetCheckoutParams): Promise<ShopifyCheckout | void> {\n    return await findCheckout({ gqlClient, id });\n  }\n\n  async function processCheckout({\n    cartItems,\n    id,\n    metafields,\n    note,\n    queueToken\n  }: ProcessCheckoutParams): Promise<ShopifyCheckout | void> {\n    const lineItems = cartItems?.length\n      ? cartItemsToCheckoutItems({ cartItems })\n      : undefined;\n\n    const customAttributes = metafields?.length\n      ? metafieldsToCustomAttributes({ metafields })\n      : undefined;\n\n    return await putCheckout({\n      gqlClient,\n      lineItems,\n      id,\n      customAttributes,\n      note,\n      queueToken\n    });\n  }\n\n  async function discountApply({\n    id,\n    discountCode,\n    queueToken\n  }: DiscountApplyParams): Promise<ShopifyCheckout | void> {\n    return await applyDiscount({ gqlClient, id, discountCode, queueToken });\n  }\n\n  async function discountRemove({\n    id,\n    queueToken\n  }: DiscountRemoveParams): Promise<ShopifyCheckout | void> {\n    return await removeDiscount({ gqlClient, id, queueToken });\n  }\n\n  return {\n    get: getCheckout,\n    process: processCheckout,\n    discountApply,\n    discountRemove\n  };\n}\n"],"names":[],"mappings":"4lBAOsC,CACpC,WACA,sBAGA,MACM,CACJ,KACA,SACA,cACA,YACA,wBACE,UAAY,CACd,GAAI,KACJ,OAAQ,KACR,UAAW,mDAQX,KACA,qLChBM,EAAY,EAAwB,SAKnC,kBAJkB,EAA6B,CACpD,WAAY,EAAS,uCCX3B,WAA+B,EAAwB,eAS9C,AARiB,wBACpB,MAAM,cACP,UAFqB,cAGpB,MAAM,MACP,QAJqB,cAKpB,MAAM,KACP,QAEuB,OAgBf,2OAEA,6NAQX,iBACA,cACA,iFASM,GAAW,4CAUX,SAAU,gHAYV,wPCpDN,KACG,EACK,OACD,GAAI,OAAO,CAAC,EAAK,EAAG,IAAM,GAAG,IAAM,IAAI,EAAO,IAAM,KAAM,eCdjE,EACA;uDCZ2C,EAAqB,OAG3D,kBAAI,6DACA,cCO0C,CACnD,cAC+C,OAC3C,CAAC,MAAM,QAAQ,IAAe,CAAC,kBAAY,QACtC,GAIgB,gDACA,2JCXrB,EAAoB,SACf,0GAqBmB,oDAQxB,6CAIS,kOCzCf,KAAM,GAAW,w1BCeJ,GAAiB,64CCe5B,mBACA,SAEA,wBAEc,yaCPd,mBACA,OACA,eAEA,4EAcI,qKAeQ,4NChCZ,OAEA,wBAEc,iCAWV,KAAM,sYCvCC,GAAc,+KCiBzB,mBAKM,kBAOF,8VCjBJ,OACA,eAEA,MACA,kEAGI,IACE,oJAiBI,KACA,eAOF,KACqB,KACrB,EAAyB,CACvB,YACA,KACA,mBACA,eAOE,yFAUgB,OACb,EAAE,eAEE,EAAE,SAAW,gBAChB,IAAI,OAAM,EAAE,4EAUtB,YACA,mBACA,OACA,iPClDF,iHAWA,+FAS2B,mDAGzB,kBAAM,+TC7BV,6IAcE,wfC4BJ,wDAGE,4HAgBA,eAEA,sHAYO,MAAM,GAAY,CACvB,YACA,YACA,KACA,oBACA,OACA,kEAMF,KACA,gJAcA,KACA"}